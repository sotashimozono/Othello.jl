var documenterSearchIndex = {"docs":
[{"location":"example/zobrist_demo/#Zobrist-Hashing-in-Reversi.jl","page":"Zobrist Hashing in Reversi.jl","title":"Zobrist Hashing in Reversi.jl","text":"","category":"section"},{"location":"example/zobrist_demo/#Overview","page":"Zobrist Hashing in Reversi.jl","title":"Overview","text":"Zobrist hashing is a technique for efficiently computing a nearly-unique integer fingerprint of a board position.  Reversi.jl keeps an incremental Zobrist hash in every ReversiGame object so that identifying positions and detecting transpositions in game-tree search costs almost nothing.\n\nusing Reversi\nusing Reversi: BLACK, WHITE, EMPTY, compute_full_hash, update_hash, ZOBRIST_TABLE","category":"section"},{"location":"example/zobrist_demo/#1.-Initial-hash","page":"Zobrist Hashing in Reversi.jl","title":"1. Initial hash","text":"Every ReversiGame is created with its hash field already set to the Zobrist hash of the four starting pieces.\n\ngame = ReversiGame()\nprintln(\"Initial incremental hash : 0x\", string(game.hash, base=16, pad=16))\nprintln(\"Full recomputed hash      : 0x\", string(compute_full_hash(game), base=16, pad=16))\n@assert game.hash == compute_full_hash(game)","category":"section"},{"location":"example/zobrist_demo/#2.-Hash-after-a-move","page":"Zobrist Hashing in Reversi.jl","title":"2. Hash after a move","text":"After each make_move! call the hash is updated incrementally — only the newly placed piece and the flipped pieces are XOR-ed in or out.  The result must always match compute_full_hash.\n\nmake_move!(game, \"d3\")   # Black plays d3\nprintln(\"\\nAfter d3:\")\nprintln(\"Incremental hash : 0x\", string(game.hash, base=16, pad=16))\nprintln(\"Full hash        : 0x\", string(compute_full_hash(game), base=16, pad=16))\n@assert game.hash == compute_full_hash(game)","category":"section"},{"location":"example/zobrist_demo/#3.-XOR-self-inverse-property","page":"Zobrist Hashing in Reversi.jl","title":"3. XOR self-inverse property","text":"Toggling the same piece twice returns the original hash — a direct consequence of XOR being its own inverse.\n\nh0 = compute_full_hash(ReversiGame())\nh1 = update_hash(h0, 3, 4, BLACK)   # add a piece\nh2 = update_hash(h1, 3, 4, BLACK)   # remove the same piece\nprintln(\"\\nOriginal hash    : 0x\", string(h0, base=16, pad=16))\nprintln(\"After toggle ×2  : 0x\", string(h2, base=16, pad=16))\n@assert h0 == h2 \"XOR inverse property failed!\"","category":"section"},{"location":"example/zobrist_demo/#4.-Position-lookup-/-transposition-detection","page":"Zobrist Hashing in Reversi.jl","title":"4. Position lookup / transposition detection","text":"Because the hash is cheap to maintain, it is ideal for transposition tables: a dictionary from hash → evaluation that avoids re-searching the same position reached via different move orders.\n\ntransposition_table = Dict{UInt64, Int}()\n\nfunction cached_piece_diff(game::ReversiGame)::Int\n    haskey(transposition_table, game.hash) && return transposition_table[game.hash]\n    black, white = count_pieces(game)\n    val = black - white\n    transposition_table[game.hash] = val\n    return val\nend\n\ng1 = ReversiGame()\nmake_move!(g1, \"d3\"); make_move!(g1, \"c5\")\n\ng2 = ReversiGame()\nmake_move!(g2, \"d3\"); make_move!(g2, \"c5\")\n\nprintln(\"\\nHash of g1: 0x\", string(g1.hash, base=16, pad=16))\nprintln(\"Hash of g2: 0x\", string(g2.hash, base=16, pad=16))\n@assert g1.hash == g2.hash \"Same move sequence must yield same hash!\"\n\nval1 = cached_piece_diff(g1)\nval2 = cached_piece_diff(g2)   # cache hit\nprintln(\"Cached piece diff: $val1  (table size: $(length(transposition_table)))\")\n@assert val1 == val2\n\nprintln(\"\\nZobrist hashing demo complete.\")\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api/rules/#Rules","page":"rules","title":"Rules","text":"The rules of Reversi is defined as follows.","category":"section"},{"location":"api/rules/#Documents","page":"rules","title":"Documents","text":"","category":"section"},{"location":"api/rules/#Reversi.compute_flips-Tuple{UInt64, UInt64, UInt64}","page":"rules","title":"Reversi.compute_flips","text":"compute_flips(pos::UInt64, player::UInt64, opponent::UInt64) -> UInt64\n\nReturn a bitmask of opponent pieces that would be flipped if player places at the single-bit position pos.\n\n\n\n\n\n","category":"method"},{"location":"api/rules/#Reversi.count_pieces-Tuple{ReversiGame}","page":"rules","title":"Reversi.count_pieces","text":"count_pieces(game::ReversiGame) -> (Int, Int)\n\nReturn (black_count, white_count).\n\n\n\n\n\n","category":"method"},{"location":"api/rules/#Reversi.get_piece-Tuple{ReversiGame, Int64, Int64}","page":"rules","title":"Reversi.get_piece","text":"get_piece(game::ReversiGame, row::Int, col::Int) -> Int\n\nReturn BLACK, WHITE, or EMPTY for the given square.\n\n\n\n\n\n","category":"method"},{"location":"api/rules/#Reversi.get_winner-Tuple{ReversiGame}","page":"rules","title":"Reversi.get_winner","text":"get_winner(game::ReversiGame) -> Int\n\nReturn BLACK, WHITE, or EMPTY (draw) based on piece counts.\n\n\n\n\n\n","category":"method"},{"location":"api/rules/#Reversi.is_game_over-Tuple{ReversiGame}","page":"rules","title":"Reversi.is_game_over","text":"is_game_over(game::ReversiGame) -> Bool\n\nReturn true when the game has ended (two consecutive passes, or board full, or neither player has any legal move).\n\n\n\n\n\n","category":"method"},{"location":"api/rules/#Reversi.is_valid_move","page":"rules","title":"Reversi.is_valid_move","text":"is_valid_move(game::ReversiGame, row::Int, col::Int[, player::Int]) -> Bool\n\nCheck if placing a piece at (row, col) is a valid move for player.\n\n\n\n\n\n","category":"function"},{"location":"api/rules/#Reversi.is_valid_position-Tuple{Int64, Int64}","page":"rules","title":"Reversi.is_valid_position","text":"is_valid_position(row::Int, col::Int) -> Bool\n\nCheck if a position is within the board boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/rules/#Reversi.legal_moves_bb-Tuple{UInt64, UInt64}","page":"rules","title":"Reversi.legal_moves_bb","text":"legal_moves_bb(player::UInt64, opponent::UInt64) -> UInt64\n\nReturn a bitmask of all squares where player can legally place a piece, using a Kogge-Stone (Dumb7Fill) flood-fill in each of the 8 directions.\n\n\n\n\n\n","category":"method"},{"location":"api/rules/#Reversi.make_move!-Tuple{ReversiGame, AbstractString}","page":"rules","title":"Reversi.make_move!","text":"make_move!(game::ReversiGame, s::AbstractString) -> Bool\n\nMake a move specified in standard Reversi notation (e.g. \"e4\").\n\n\n\n\n\n","category":"method"},{"location":"api/rules/#Reversi.make_move!-Tuple{ReversiGame, Int64, Int64}","page":"rules","title":"Reversi.make_move!","text":"make_move!(game::ReversiGame, row::Int, col::Int) -> Bool\n\nPlace a piece at (row, col) for the current player.  Updates the board and the incremental Zobrist hash.  Returns true on success, false if the move is illegal.\n\n\n\n\n\n","category":"method"},{"location":"api/rules/#Reversi.make_move!-Tuple{ReversiGame, Position}","page":"rules","title":"Reversi.make_move!","text":"make_move!(game::ReversiGame, pos::Position) -> Bool\n\nMake a move at the given Position.\n\n\n\n\n\n","category":"method"},{"location":"api/rules/#Reversi.next_state-Tuple{ReversiGame, AbstractString}","page":"rules","title":"Reversi.next_state","text":"next_state(game::ReversiGame, move::AbstractString) -> ReversiGame\n\nCopy-on-move variant that accepts standard Reversi notation (e.g. \"e4\").\n\n\n\n\n\n","category":"method"},{"location":"api/rules/#Reversi.next_state-Tuple{ReversiGame, Position}","page":"rules","title":"Reversi.next_state","text":"next_state(game::ReversiGame, move::Position) -> ReversiGame\n\nReturn a new ReversiGame that results from applying move to a deep copy of game.  The original game is not modified (copy-on-move semantics).\n\n\n\n\n\n","category":"method"},{"location":"api/rules/#Reversi.opponent-Tuple{Int64}","page":"rules","title":"Reversi.opponent","text":"opponent(player::Int) -> Int\n\nReturns the opponent's color.\n\n\n\n\n\n","category":"method"},{"location":"api/rules/#Reversi.pass!-Tuple{ReversiGame}","page":"rules","title":"Reversi.pass!","text":"pass!(game::ReversiGame)\n\nPass the turn to the opponent and increment the consecutive-pass counter.\n\n\n\n\n\n","category":"method"},{"location":"api/rules/#Reversi.valid_moves","page":"rules","title":"Reversi.valid_moves","text":"valid_moves(game::ReversiGame[, player::Int]) -> Vector{Position}\n\nReturn all valid moves for player (defaults to game.current_player).\n\n\n\n\n\n","category":"function"},{"location":"example/ml_integration/#Example:-Creating-a-Custom-AI-Player-for-Machine-Learning-Integration","page":"machine learning","title":"Example: Creating a Custom AI Player for Machine Learning Integration","text":"This example demonstrates how to create custom players that can integrate with machine learning frameworks like Flux.jl or reinforcement learning libraries.\n\nusing Reversi\nusing Reversi: BLACK, WHITE, EMPTY, count_pieces, is_game_over, opponent","category":"section"},{"location":"example/ml_integration/#Example-1:-Simple-Heuristic-Player","page":"machine learning","title":"Example 1: Simple Heuristic Player","text":"This player uses a position-based heuristic Corner squares are valuable, edges are decent, next to corners are bad\n\nstruct HeuristicPlayer <: Player\n    weights::Matrix{Float64}\n\n    function HeuristicPlayer()\n        weights = [\n            100 -20 10 5 5 10 -20 100;\n            -20 -50 -2 -2 -2 -2 -50 -20;\n            10 -2 5 3 3 5 -2 10;\n            5 -2 3 1 1 3 -2 5;\n            5 -2 3 1 1 3 -2 5;\n            10 -2 5 3 3 5 -2 10;\n            -20 -50 -2 -2 -2 -2 -50 -20;\n            100 -20 10 5 5 10 -20 100\n        ]\n        new(weights)\n    end\nend\n\nfunction Reversi.get_move(player::HeuristicPlayer, game::ReversiGame)\n    moves = valid_moves(game)\n\n    if isempty(moves)\n        return nothing\n    end\n\n    best_move = moves[1]\n    best_score = player.weights[best_move.row, best_move.col]\n\n    for move in moves[2:end]\n        score = player.weights[move.row, move.col]\n        if score > best_score\n            best_score = score\n            best_move = move\n        end\n    end\n\n    return best_move\nend","category":"section"},{"location":"example/ml_integration/#Example-2:-Player-that-tracks-game-state-for-ML-training","page":"machine learning","title":"Example 2: Player that tracks game state for ML training","text":"Board state is represented as a plain Matrix{Int} where 0 = empty, 1 = BLACK, 2 = WHITE — no external dependencies required.\n\nmutable struct TrainingPlayer <: Player\n    move_history::Vector{Tuple{Matrix{Int},Position}}\n\n    TrainingPlayer() = new(Tuple{Matrix{Int},Position}[])\nend\n\n\"\"\"\n    board_to_matrix(game::ReversiGame) -> Matrix{Int}\n\nConvert the bitboard state of `game` into an 8×8 `Matrix{Int}` where\n`EMPTY == 0`, `BLACK == 1`, and `WHITE == 2`.\n\"\"\"\nfunction board_to_matrix(game::ReversiGame)\n    mat = zeros(Int, 8, 8)\n    for row in 1:8, col in 1:8\n        mat[row, col] = get_piece(game, row, col)\n    end\n    return mat\nend\n\nRecord the board state as a plain matrix Make a random move (in practice, this would use your ML model) Store the state-action pair for training\n\nfunction Reversi.get_move(player::TrainingPlayer, game::ReversiGame)\n    moves = valid_moves(game)\n\n    if isempty(moves)\n        return nothing\n    end\n\n    board_copy = board_to_matrix(game)\n    move = rand(moves)\n    push!(player.move_history, (board_copy, move))\n\n    return move\nend","category":"section"},{"location":"example/ml_integration/#Example-3:-Mock-Neural-Network-Player","page":"machine learning","title":"Example 3: Mock Neural Network Player","text":"This shows the structure for integrating with a real neural network In practice, this would be your trained model from Flux, TensorFlow, etc.\n\nstruct NeuralNetPlayer <: Player\n    model\nend\n\nConvert board to neural network input In practice: input = preprocessboard(game.board, game.currentplayer) For demo, we'll just use random\n\nGet policy from neural network In practice: policy = player.model(input)\n\nSelect move based on policy In practice: return selectmovefrom_policy(policy, moves)\n\nfunction Reversi.get_move(player::NeuralNetPlayer, game::ReversiGame)\n    moves = valid_moves(game)\n\n    if isempty(moves)\n        return nothing\n    end\n\n    return rand(moves)\nend\n\nExample 4: Minimax Player (game tree search)\n\nstruct MinimaxPlayer <: Player\n    depth::Int\n    MinimaxPlayer(depth=3) = new(depth)\nend\n\nSimple evaluation: piece count difference\n\nfunction evaluate_board(game::ReversiGame, player_color::Int)\n    black, white = count_pieces(game)\n    return player_color == BLACK ? (black - white) : (white - black)\nend\n\nfunction minimax(\n    game::ReversiGame,\n    depth::Int,\n    maximizing::Bool,\n    alpha::Float64,\n    beta::Float64,\n    player_color::Int,\n)\n    if depth == 0 || is_game_over(game)\n        return evaluate_board(game, player_color)\n    end\n\n    moves = valid_moves(game)\n\n    if isempty(moves)\n        temp_game = deepcopy(game)\n        temp_game.current_player = opponent(temp_game.current_player)\n        temp_game.pass_count += 1\n        return minimax(temp_game, depth - 1, !maximizing, alpha, beta, player_color)\n    end\n\n    if maximizing\n        max_eval = -Inf\n        for move in moves\n            temp_game = deepcopy(game)\n            make_move!(temp_game, move.row, move.col)\n            eval = minimax(temp_game, depth - 1, false, alpha, beta, player_color)\n            max_eval = max(max_eval, eval)\n            alpha = max(alpha, eval)\n            if beta <= alpha\n                break\n            end\n        end\n        return max_eval\n    else\n        min_eval = Inf\n        for move in moves\n            temp_game = deepcopy(game)\n            make_move!(temp_game, move.row, move.col)\n            eval = minimax(temp_game, depth - 1, true, alpha, beta, player_color)\n            min_eval = min(min_eval, eval)\n            beta = min(beta, eval)\n            if beta <= alpha\n                break\n            end\n        end\n        return min_eval\n    end\nend\n\nfunction Reversi.get_move(player::MinimaxPlayer, game::ReversiGame)\n    moves = valid_moves(game)\n\n    if isempty(moves)\n        return nothing\n    end\n\n    best_move = moves[1]\n    best_score = -Inf\n\n    for move in moves\n        temp_game = deepcopy(game)\n        make_move!(temp_game, move.row, move.col)\n        score = minimax(temp_game, player.depth - 1, false, -Inf, Inf, game.current_player)\n\n        if score > best_score\n            best_score = score\n            best_move = move\n        end\n    end\n\n    return best_move\nend\n\nprintln(\"=\"^60)\nprintln(\"Machine Learning Integration Examples\")\nprintln(\"=\"^60)\nprintln()\n\nprintln(\"Test 1: Heuristic Player vs Random\")\nprintln(\"-\"^60)\nwinner = play_game(HeuristicPlayer(), RandomPlayer(); verbose=false)\nwinner_str =\n    winner == BLACK ? \"Heuristic (Black)\" : (winner == WHITE ? \"Random (White)\" : \"Draw\")\nprintln(\"Winner: $winner_str\")\nprintln()\n\nprintln(\"Test 2: Training Player (collecting data)\")\nprintln(\"-\"^60)\ntraining_player = TrainingPlayer()\nwinner = play_game(training_player, RandomPlayer(); verbose=false)\nprintln(\"Collected $(length(training_player.move_history)) state-action pairs for training\")\nprintln()\n\nprintln(\"Test 3: Minimax Player vs Random (depth=2)\")\nprintln(\"-\"^60)\nwinner = play_game(MinimaxPlayer(2), RandomPlayer(); verbose=false)\nwinner_str =\n    winner == BLACK ? \"Minimax (Black)\" : (winner == WHITE ? \"Random (White)\" : \"Draw\")\nprintln(\"Winner: $winner_str\")\nprintln()\n\nprintln(\"=\"^60)\nprintln(\"Integration Examples Complete!\")\nprintln()\nprintln(\"Key Takeaways:\")\nprintln(\"  1. Abstract Player type enables easy custom implementations\")\nprintln(\"  2. Game state can be copied for tree search (Minimax, MCTS)\")\nprintln(\"  3. State-action pairs can be collected for supervised learning\")\nprintln(\"  4. Neural network policies can be integrated seamlessly\")\nprintln(\"=\"^60)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api/data/#Data","page":"data","title":"Data","text":"Data of Reversi.jl.","category":"section"},{"location":"api/data/#Documents","page":"data","title":"Documents","text":"","category":"section"},{"location":"api/data/#Reversi.GameRecord","page":"data","title":"Reversi.GameRecord","text":"GameRecord\n\nStores the complete move history of a finished (or in-progress) Reversi game as a vector of standard notation strings (e.g. [\"d3\", \"c5\", ...]).\n\nFields:\n\nmoves::Vector{String} – ordered list of moves in standard notation.\nresult::Int           – BLACK, WHITE, or EMPTY (draw); 2 when not yet finished.\n\n\n\n\n\n","category":"type"},{"location":"api/data/#Reversi.load_game-Tuple{String}","page":"data","title":"Reversi.load_game","text":"load_game(filepath::String) -> GameRecord\n\nRead a GameRecord from a file previously written by save_game.\n\n\n\n\n\n","category":"method"},{"location":"api/data/#Reversi.play_game-Tuple{Player, Player}","page":"data","title":"Reversi.play_game","text":"play_game(player1::Player, player2::Player;\n          verbose::Bool=true, save_record::Bool=false,\n          record_path::String=\"game_record.txt\") -> Int\n\nExtended version of play_game that optionally saves the move history. When save_record=true the record is written to record_path after the game. Returns the winner (BLACK, WHITE, or EMPTY).\n\n\n\n\n\n","category":"method"},{"location":"api/data/#Reversi.replay_game-Tuple{GameRecord}","page":"data","title":"Reversi.replay_game","text":"replay_game(record::GameRecord; verbose::Bool=false) -> ReversiGame\n\nReplay all moves stored in record on a fresh ReversiGame and return the resulting game state.  Passes are represented by the special token \"pass\".\n\n\n\n\n\n","category":"method"},{"location":"api/data/#Reversi.save_game-Tuple{GameRecord, String}","page":"data","title":"Reversi.save_game","text":"save_game(record::GameRecord, filepath::String)\n\nWrite a GameRecord to filepath in a simple text format.\n\nFormat:\n\nMOVES: d3 c5 f4 ...\nRESULT: BLACK | WHITE | DRAW\n\n\n\n\n\n","category":"method"},{"location":"example/demo/#How-to-Play-with-Reversi.jl","page":"quickstart","title":"How to Play with Reversi.jl","text":"","category":"section"},{"location":"example/demo/#Example1:-script-demonstrating-Reversi.jl-usage","page":"quickstart","title":"Example1: script demonstrating Reversi.jl usage","text":"using Reversi\n\nprintln(\"=\"^60)\nprintln(\"Reversi.jl Demo\")\nprintln(\"=\"^60)\nprintln()\n\nExample 1: Play a game between two random players\n\nprintln(\"Example 1: Two Random Players\")\nprintln(\"-\" * \"=\"^59)\nwinner = play_game(RandomPlayer(), RandomPlayer(); verbose=true)\nprintln()","category":"section"},{"location":"example/demo/#Example-2:-Create-a-custom-player-that-prefers-corner-moves","page":"quickstart","title":"Example 2: Create a custom player that prefers corner moves","text":"struct CornerPlayer <: Player end\nfunction Reversi.get_move(player::CornerPlayer, game::ReversiGame)\n    moves = valid_moves(game)\n    if isempty(moves)\n        return nothing\n    end\n    corners = [Position(1, 1), Position(1, 8), Position(8, 1), Position(8, 8)]\n    for corner in corners\n        if corner in moves\n            return corner\n        end\n    end\n    return rand(moves)\nend\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Example 2: Corner-Preferring Player vs Random Player\")\nprintln(\"-\" * \"=\"^59)\nwinner = play_game(CornerPlayer(), RandomPlayer(); verbose=true)\nprintln()\n\nExample 3: Programmatic game control\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Example 3: Programmatic Control\")\nprintln(\"-\" * \"=\"^59)\n\ngame = ReversiGame()\nprintln(\"Initial board:\")\ndisplay_board(game)\n\nprintln(\"\\nMaking first move at (3, 4)...\")\nmake_move!(game, 3, 4)\ndisplay_board(game)\n\nprintln(\"\\nValid moves for current player:\")\nmoves = valid_moves(game)\nfor move in moves\n    println(\"  ($(move.row), $(move.col))\")\nend\n\nprintln(\"\\n\" * \"=\"^60)\nprintln(\"Demo Complete!\")\nprintln(\"=\"^60)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api/struct/#Struct","page":"struct","title":"Struct","text":"These structs are basis of Reversi.jl.","category":"section"},{"location":"api/struct/#Documents","page":"struct","title":"Documents","text":"","category":"section"},{"location":"api/struct/#Reversi.ZOBRIST_TABLE","page":"struct","title":"Reversi.ZOBRIST_TABLE","text":"ZOBRIST_TABLE\n\n128-entry table of random UInt64 values indexed by [row, col, color_idx] (color_idx 1 = BLACK, 2 = WHITE) used for incremental Zobrist hashing.\n\n\n\n\n\n","category":"constant"},{"location":"api/struct/#Reversi.Position","page":"struct","title":"Reversi.Position","text":"Position\n\nRepresents a position on the Reversi board (row, col). Supports construction from standard Reversi notation (e.g. \"e4\").\n\n\n\n\n\n","category":"type"},{"location":"api/struct/#Reversi.Position-Tuple{AbstractString}","page":"struct","title":"Reversi.Position","text":"Position(s::AbstractString) -> Position\n\nParse a standard Reversi notation string (e.g. \"e4\") into a Position. Column letters a–h map to columns 1–8; row digits 1–8 map to rows 1–8.\n\nExamples\n\nPosition(\"e4\")  # Position(4, 5)\nPosition(\"a1\")  # Position(1, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/struct/#Reversi.ReversiGame","page":"struct","title":"Reversi.ReversiGame","text":"ReversiGame\n\nRepresents the state of a Reversi game using two UInt64 bitboards.\n\nFields:\n\nblack::UInt64  – bitmask of squares occupied by Black (bit (row-1)*8+(col-1))\nwhite::UInt64  – bitmask of squares occupied by White\ncurrent_player::Int – BLACK or WHITE\npass_count::Int – consecutive passes (≥ 2 → game over)\nhash::UInt64   – incremental Zobrist hash of the current position\n\n\n\n\n\n","category":"type"},{"location":"api/struct/#Reversi.compute_full_hash-Tuple{ReversiGame}","page":"struct","title":"Reversi.compute_full_hash","text":"compute_full_hash(game::ReversiGame) -> UInt64\n\nCompute the Zobrist hash of game from scratch by XOR-ing the table entries for every piece currently on the board.  Useful for initialisation and debugging.\n\n\n\n\n\n","category":"method"},{"location":"api/struct/#Reversi.position_to_string-Tuple{Position}","page":"struct","title":"Reversi.position_to_string","text":"position_to_string(pos::Position) -> String\n\nConvert a Position to standard Reversi notation (e.g. Position(4, 5) → \"e4\").\n\n\n\n\n\n","category":"method"},{"location":"api/struct/#Reversi.update_hash-Tuple{UInt64, Int64, Int64, Int64}","page":"struct","title":"Reversi.update_hash","text":"update_hash(current_hash::UInt64, row::Int, col::Int, color::Int) -> UInt64\n\nReturn the hash obtained by toggling one piece of color at (row, col). Because XOR is self-inverse, this both adds and removes the piece, matching the Zobrist property A ⊕ A = 0.\n\n\n\n\n\n","category":"method"},{"location":"example/play/","page":"play","title":"play","text":"Interactive terminal Reversi game\n\nusing Reversi\n\n\nprintln(\"=\"^60)\nprintln(\"Welcome to Reversi!\")\nprintln(\"=\"^60)\nprintln()\nprintln(\"Rules:\")\nprintln(\"  - Black (●) plays first\")\nprintln(\"  - You must flip at least one opponent piece\")\nprintln(\"  - If no valid moves, you must pass\")\nprintln(\"  - Game ends when both players pass or board is full\")\nprintln()\n\nfunction select_game_mode()\n    println(\"Select game mode:\")\n    println(\"  1. Human (Black) vs Random AI (White)\")\n    println(\"  2. Human (White) vs Random AI (Black)\")\n    println(\"  3. Human vs Human\")\n    println(\"  4. Random AI vs Random AI (watch)\")\n\n    while true\n        print(\"Enter choice (1-4): \")\n        input = readline()\n        choice = tryparse(Int, strip(input))\n\n        if choice !== nothing && 1 <= choice <= 4\n            return choice\n        end\n        println(\"Invalid choice. Please enter 1, 2, 3, or 4.\")\n    end\nend\n\nWhen you play this example, you can uncomment the line below and disalbing mode=4. mode = selectgamemode()\n\nmode = 4\nprintln()\n\nif mode == 1\n    println(\"You are Black (●), AI is White (○)\")\n    player1 = HumanPlayer()\n    player2 = RandomPlayer()\nelseif mode == 2\n    println(\"AI is Black (●), You are White (○)\")\n    player1 = RandomPlayer()\n    player2 = HumanPlayer()\nelseif mode == 3\n    println(\"Human vs Human mode\")\n    player1 = HumanPlayer()\n    player2 = HumanPlayer()\nelse\n    println(\"Watch mode: AI vs AI\")\n    player1 = RandomPlayer()\n    player2 = RandomPlayer()\nend\n\nprintln()\nplay_game(player1, player2; verbose=true)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#Reversi.jl-Documentation","page":"Home","title":"Reversi.jl Documentation","text":"A high-performance Reversi (Othello) implementation in Julia, built on StaticArrays.jl for efficient board representation. Designed with flexibility for machine learning research and reinforcement learning applications.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Efficient Implementation: Uses StaticArrays.jl for fast, stack-allocated board representation\nTerminal Gameplay: Play interactively in the terminal\nFlexible Player System: Easy to integrate custom AI players and ML models\nClean API: Simple, well-documented interface for programmatic control\nExtensible: Abstract player interface allows easy implementation of new strategies","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/sotashimozono/Reversi.jl\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Play-in-Terminal","page":"Home","title":"Play in Terminal","text":"using Reversi\n\n# Human vs Random AI\nplay_game(HumanPlayer(), RandomPlayer())","category":"section"},{"location":"#Create-Custom-AI-Players","page":"Home","title":"Create Custom AI Players","text":"using Reversi\n\n# Define a custom player type\nstruct MyAIPlayer <: Player end\n\n# Implement the get_move function\nfunction Reversi.get_move(player::MyAIPlayer, game::ReversiGame)\n    moves = valid_moves(game)\n    \n    if isempty(moves)\n        return nothing  # Pass turn\n    end\n    \n    # Your AI logic here\n    return moves[1]  # Example: pick first valid move\nend\n\n# Play a game\nplay_game(MyAIPlayer(), RandomPlayer())","category":"section"},{"location":"api/game/#Game","page":"game","title":"Game","text":"UI of Reversi.jl. only CUI is available.","category":"section"},{"location":"api/game/#Documents","page":"game","title":"Documents","text":"","category":"section"},{"location":"api/game/#Reversi.display_board-Tuple{ReversiGame}","page":"game","title":"Reversi.display_board","text":"display_board(game::ReversiGame; hints::Vector{Position}=Position[])\n\nDisplay the current board state in the terminal. Columns are labelled a–h and rows 1–8. Optional hints highlights valid moves with a green *.\n\n\n\n\n\n","category":"method"},{"location":"api/player/#Player","page":"player","title":"Player","text":"In Reversi.jl, managing operations with Player struct.","category":"section"},{"location":"api/player/#Documents","page":"player","title":"Documents","text":"","category":"section"},{"location":"api/player/#Reversi.HumanPlayer","page":"player","title":"Reversi.HumanPlayer","text":"HumanPlayer <: Player\n\nA player that gets moves from terminal input.\n\n\n\n\n\n","category":"type"},{"location":"api/player/#Reversi.Player","page":"player","title":"Reversi.Player","text":"Player\n\nAbstract type for all player implementations. if you want to create a new player type, subtype Player and implement the get_move function.\n\n\n\n\n\n","category":"type"},{"location":"api/player/#Reversi.RandomPlayer","page":"player","title":"Reversi.RandomPlayer","text":"RandomPlayer <: Player\n\nA player that makes random valid moves.\n\n\n\n\n\n","category":"type"},{"location":"api/player/#Reversi.get_move","page":"player","title":"Reversi.get_move","text":"get_move(player::Player, game::ReversiGame) -> Union{Position, Nothing}\n\nGet the next move from a player. Returns Nothing if the player wants to pass.\n\n\n\n\n\n","category":"function"}]
}
