var documenterSearchIndex = {"docs":
[{"location":"#Reversi.jl-Documentation","page":"Home","title":"Reversi.jl Documentation","text":"A high-performance Reversi (Othello) implementation in Julia, built on StaticArrays.jl for efficient board representation. Designed with flexibility for machine learning research and reinforcement learning applications.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Efficient Implementation: Uses StaticArrays.jl for fast, stack-allocated board representation\nTerminal Gameplay: Play interactively in the terminal\nFlexible Player System: Easy to integrate custom AI players and ML models\nClean API: Simple, well-documented interface for programmatic control\nExtensible: Abstract player interface allows easy implementation of new strategies","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/sotashimozono/Reversi.jl\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Play-in-Terminal","page":"Home","title":"Play in Terminal","text":"using Reversi\n\n# Human vs Random AI\nplay_game(HumanPlayer(), RandomPlayer())","category":"section"},{"location":"#Create-Custom-AI-Players","page":"Home","title":"Create Custom AI Players","text":"using Reversi\n\n# Define a custom player type\nstruct MyAIPlayer <: Player end\n\n# Implement the get_move function\nfunction Reversi.get_move(player::MyAIPlayer, game::ReversiGame)\n    moves = valid_moves(game)\n    \n    if isempty(moves)\n        return nothing  # Pass turn\n    end\n    \n    # Your AI logic here\n    return moves[1]  # Example: pick first valid move\nend\n\n# Play a game\nplay_game(MyAIPlayer(), RandomPlayer())","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"#Reversi.ZOBRIST_TABLE","page":"Home","title":"Reversi.ZOBRIST_TABLE","text":"ZOBRIST_TABLE\n\n128-entry table of random UInt64 values indexed by [row, col, color] (color 1 = BLACK, 2 = WHITE) used for incremental Zobrist hashing.\n\n\n\n\n\n","category":"constant"},{"location":"#Reversi.HumanPlayer","page":"Home","title":"Reversi.HumanPlayer","text":"HumanPlayer <: Player\n\nA player that gets moves from terminal input.\n\n\n\n\n\n","category":"type"},{"location":"#Reversi.Player","page":"Home","title":"Reversi.Player","text":"Player\n\nAbstract type for all player implementations. if you want to create a new player type, subtype Player and implement the get_move function.\n\n\n\n\n\n","category":"type"},{"location":"#Reversi.Position","page":"Home","title":"Reversi.Position","text":"Position\n\nRepresents a position on the Reversi board (row, col). Supports construction from standard Reversi notation (e.g. \"e4\").\n\n\n\n\n\n","category":"type"},{"location":"#Reversi.Position-Tuple{AbstractString}","page":"Home","title":"Reversi.Position","text":"Position(s::AbstractString) -> Position\n\nParse a standard Reversi notation string (e.g. \"e4\") into a Position. Column letters a–h map to columns 1–8; row digits 1–8 map to rows 1–8.\n\nExamples\n\nPosition(\"e4\")  # Position(4, 5)\nPosition(\"a1\")  # Position(1, 1)\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.RandomPlayer","page":"Home","title":"Reversi.RandomPlayer","text":"RandomPlayer <: Player\n\nA player that makes random valid moves.\n\n\n\n\n\n","category":"type"},{"location":"#Reversi.ReversiGame","page":"Home","title":"Reversi.ReversiGame","text":"ReversiGame\n\nRepresents the state of a Reversi game using two UInt64 bitboards.\n\nFields:\n\nblack::UInt64  – bitmask of squares occupied by Black (bit (row-1)*8+(col-1))\nwhite::UInt64  – bitmask of squares occupied by White\ncurrent_player::Int – BLACK or WHITE\npass_count::Int – consecutive passes (≥ 2 → game over)\nhash::UInt64   – incremental Zobrist hash of the current position\n\n\n\n\n\n","category":"type"},{"location":"#Reversi.compute_flips-Tuple{UInt64, UInt64, UInt64}","page":"Home","title":"Reversi.compute_flips","text":"compute_flips(pos::UInt64, player::UInt64, opponent::UInt64) -> UInt64\n\nReturn a bitmask of opponent pieces that would be flipped if player places at the single-bit position pos.\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.compute_full_hash-Tuple{ReversiGame}","page":"Home","title":"Reversi.compute_full_hash","text":"compute_full_hash(game::ReversiGame) -> UInt64\n\nCompute the Zobrist hash of game from scratch by XOR-ing the table entries for every piece currently on the board.  Useful for initialisation and debugging.\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.count_pieces-Tuple{ReversiGame}","page":"Home","title":"Reversi.count_pieces","text":"count_pieces(game::ReversiGame) -> (Int, Int)\n\nReturn (black_count, white_count).\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.display_board-Tuple{ReversiGame}","page":"Home","title":"Reversi.display_board","text":"display_board(game::ReversiGame; hints::Vector{Position}=Position[])\n\nDisplay the current board state in the terminal. Columns are labelled a–h and rows 1–8. Optional hints highlights valid moves with a green *.\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.get_move","page":"Home","title":"Reversi.get_move","text":"get_move(player::Player, game::ReversiGame) -> Union{Position, Nothing}\n\nGet the next move from a player. Returns Nothing if the player wants to pass.\n\n\n\n\n\n","category":"function"},{"location":"#Reversi.get_piece-Tuple{ReversiGame, Int64, Int64}","page":"Home","title":"Reversi.get_piece","text":"get_piece(game::ReversiGame, row::Int, col::Int) -> Int\n\nReturn BLACK, WHITE, or EMPTY for the given square.\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.get_winner-Tuple{ReversiGame}","page":"Home","title":"Reversi.get_winner","text":"get_winner(game::ReversiGame) -> Int\n\nReturn BLACK, WHITE, or EMPTY (draw) based on piece counts.\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.is_game_over-Tuple{ReversiGame}","page":"Home","title":"Reversi.is_game_over","text":"is_game_over(game::ReversiGame) -> Bool\n\nReturn true when the game has ended (two consecutive passes, or board full, or neither player has any legal move).\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.is_valid_move","page":"Home","title":"Reversi.is_valid_move","text":"is_valid_move(game::ReversiGame, row::Int, col::Int[, player::Int]) -> Bool\n\nCheck if placing a piece at (row, col) is a valid move for player.\n\n\n\n\n\n","category":"function"},{"location":"#Reversi.is_valid_position-Tuple{Int64, Int64}","page":"Home","title":"Reversi.is_valid_position","text":"is_valid_position(row::Int, col::Int) -> Bool\n\nCheck if a position is within the board boundaries.\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.legal_moves_bb-Tuple{UInt64, UInt64}","page":"Home","title":"Reversi.legal_moves_bb","text":"legal_moves_bb(player::UInt64, opponent::UInt64) -> UInt64\n\nReturn a bitmask of all squares where player can legally place a piece, using a Kogge-Stone (Dumb7Fill) flood-fill in each of the 8 directions.\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.make_move!-Tuple{ReversiGame, AbstractString}","page":"Home","title":"Reversi.make_move!","text":"make_move!(game::ReversiGame, s::AbstractString) -> Bool\n\nMake a move specified in standard Reversi notation (e.g. \"e4\").\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.make_move!-Tuple{ReversiGame, Int64, Int64}","page":"Home","title":"Reversi.make_move!","text":"make_move!(game::ReversiGame, row::Int, col::Int) -> Bool\n\nPlace a piece at (row, col) for the current player.  Updates the board and the incremental Zobrist hash.  Returns true on success, false if the move is illegal.\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.make_move!-Tuple{ReversiGame, Position}","page":"Home","title":"Reversi.make_move!","text":"make_move!(game::ReversiGame, pos::Position) -> Bool\n\nMake a move at the given Position.\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.next_state-Tuple{ReversiGame, AbstractString}","page":"Home","title":"Reversi.next_state","text":"next_state(game::ReversiGame, move::AbstractString) -> ReversiGame\n\nCopy-on-move variant that accepts standard Reversi notation (e.g. \"e4\").\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.next_state-Tuple{ReversiGame, Position}","page":"Home","title":"Reversi.next_state","text":"next_state(game::ReversiGame, move::Position) -> ReversiGame\n\nReturn a new ReversiGame that results from applying move to a deep copy of game.  The original game is not modified (copy-on-move semantics).\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.opponent-Tuple{Int64}","page":"Home","title":"Reversi.opponent","text":"opponent(player::Int) -> Int\n\nReturns the opponent's color.\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.pass!-Tuple{ReversiGame}","page":"Home","title":"Reversi.pass!","text":"pass!(game::ReversiGame)\n\nPass the turn to the opponent and increment the consecutive-pass counter.\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.play_game-Tuple{Player, Player}","page":"Home","title":"Reversi.play_game","text":"play_game(player1::Player, player2::Player; verbose::Bool=true) -> Int\n\nPlay a complete game between two players. Returns the winner.\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.position_to_string-Tuple{Position}","page":"Home","title":"Reversi.position_to_string","text":"position_to_string(pos::Position) -> String\n\nConvert a Position to standard Reversi notation (e.g. Position(4, 5) → \"e4\").\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.update_hash-Tuple{UInt64, Int64, Int64, Int64}","page":"Home","title":"Reversi.update_hash","text":"update_hash(current_hash::UInt64, row::Int, col::Int, color::Int) -> UInt64\n\nReturn the hash obtained by toggling one piece of color at (row, col). Because XOR is self-inverse, this both adds and removes the piece, matching the Zobrist property A ⊕ A = 0.\n\n\n\n\n\n","category":"method"},{"location":"#Reversi.valid_moves","page":"Home","title":"Reversi.valid_moves","text":"valid_moves(game::ReversiGame[, player::Int]) -> Vector{Position}\n\nReturn all valid moves for player (defaults to game.current_player).\n\n\n\n\n\n","category":"function"}]
}
